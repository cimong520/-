# 全局数据结构使用方案 - 土壤湿度数据存储

## 📋 当前数据结构分析

### 现有的数据结构定义（User/main.h）

```c
// 变量结构体 - 存储传感器实时数据
typedef struct 
{
    float Temp;      // 温度
    float Humi;      // 湿度
    float MH_RD;     // 预留字段（可能是土壤相关）
} var;

// 阈值结构体 - 存储控制阈值
typedef struct 
{
    float Temp;      // 温度阈值
    float Humi;      // 湿度阈值
} thresh;

// 标志位结构体 - 存储状态标志
typedef struct 
{
    u8 i;
    u8 mode;
    u8 key1, key2, key3, key4;
    int x, y, z;
    u8 led;
    u16 motor_flag;
} flg;

// 总数据结构
typedef struct 
{
    var Variable;       // 变量数据
    thresh Threshold;   // 阈值数据
    flg flag;           // 标志位
} dt;

extern dt data;  // 全局数据对象
```

## 🎯 方案一：使用现有的MH_RD字段（推荐）⭐

### 实现代码
```c
void Update_TempHuim_Display(void)
{
    DHT11_Read_Data(&temp, &humi);
    
    // 更新温湿度到全局数据结构
    data.Variable.Temp = (float)temp;
    data.Variable.Humi = (float)humi;
    
    static float Humi_Soil;
    Humi_Soil = Get_SoilHumi(ADC_Channel_7, 10);
    
    // 更新土壤湿度到全局数据结构（使用MH_RD字段）
    data.Variable.MH_RD = Humi_Soil;
    
    // ... 显示代码
}
```

### 为什么这样做？

#### 1. **数据结构已经预留了字段**
```c
typedef struct 
{
    float Temp;      // 温度
    float Humi;      // 湿度
    float MH_RD;     // ← 这个字段可能就是为土壤湿度预留的！
} var;
```
- `MH_RD` 可能代表 "Moisture Humidity - Read" 或类似含义
- 已经存在的字段，直接使用即可

#### 2. **保持数据结构一致性**
```c
// 温度和湿度的存储方式
data.Variable.Temp = (float)temp;  // 存储到Variable结构体的Temp字段
data.Variable.Humi = (float)humi;  // 存储到Variable结构体的Humi字段

// 土壤湿度也应该存储到Variable结构体
data.Variable.MH_RD = Humi_Soil;   // 存储到Variable结构体的MH_RD字段
```

#### 3. **便于其他模块访问**
```c
// 在任何地方都可以访问这些数据
float current_temp = data.Variable.Temp;      // 读取温度
float current_humi = data.Variable.Humi;      // 读取湿度
float current_soil = data.Variable.MH_RD;     // 读取土壤湿度

// 例如在云端上传函数中
void upload_data(void) {
    sprintf(buff, 
        "{\"Temp\":%.1f,\"Humi\":%.1f,\"Soil\":%.1f}",
        data.Variable.Temp,
        data.Variable.Humi,
        data.Variable.MH_RD  // 可以直接使用
    );
}
```

#### 4. **支持自动控制逻辑**
```c
// 在报警或控制函数中
void Alarm(void) {
    // 根据土壤湿度自动控制继电器
    if(data.Variable.MH_RD < 30.0) {  // 土壤太干
        relay_ON();   // 开启浇水
    } else if(data.Variable.MH_RD > 70.0) {  // 土壤湿润
        relay_OFF();  // 关闭浇水
    }
}
```

## 🎯 方案二：添加新的Soil字段（更清晰）

### 修改数据结构（需要修改main.h）
```c
// 修改变量结构体
typedef struct 
{
    float Temp;      // 温度
    float Humi;      // 湿度
    float Soil;      // 土壤湿度（新增）
    float MH_RD;     // 保留原字段
} var;
```

### 实现代码
```c
void Update_TempHuim_Display(void)
{
    DHT11_Read_Data(&temp, &humi);
    
    data.Variable.Temp = (float)temp;
    data.Variable.Humi = (float)humi;
    
    static float Humi_Soil;
    Humi_Soil = Get_SoilHumi(ADC_Channel_7, 10);
    
    // 更新土壤湿度到全局数据结构
    data.Variable.Soil = Humi_Soil;
    
    // ... 显示代码
}
```

### 为什么这样做？

#### 1. **语义更清晰**
```c
data.Variable.Soil  // 一看就知道是土壤湿度
vs
data.Variable.MH_RD // 需要猜测含义
```

#### 2. **代码可读性更好**
```c
// 方案二：清晰明了
if(data.Variable.Soil < 30.0) {
    relay_ON();
}

// 方案一：需要理解MH_RD的含义
if(data.Variable.MH_RD < 30.0) {
    relay_ON();
}
```

## 🎯 方案三：添加土壤阈值（完整方案）

### 修改数据结构
```c
// 变量结构体
typedef struct 
{
    float Temp;
    float Humi;
    float Soil;      // 土壤湿度
} var;

// 阈值结构体（也添加土壤阈值）
typedef struct 
{
    float Temp;
    float Humi;
    float Soil;      // 土壤湿度阈值
} thresh;
```

### 实现代码
```c
void Update_TempHuim_Display(void)
{
    DHT11_Read_Data(&temp, &humi);
    
    data.Variable.Temp = (float)temp;
    data.Variable.Humi = (float)humi;
    
    static float Humi_Soil;
    Humi_Soil = Get_SoilHumi(ADC_Channel_7, 10);
    data.Variable.Soil = Humi_Soil;  // 存储实时值
    
    // ... 显示代码
}

// 在初始化时设置阈值
void Data_Init(void) {
    data.Threshold.Temp = 30.0;  // 温度阈值
    data.Threshold.Humi = 60.0;  // 湿度阈值
    data.Threshold.Soil = 40.0;  // 土壤湿度阈值
}

// 在控制逻辑中使用
void Alarm(void) {
    if(data.Variable.Soil < data.Threshold.Soil) {
        relay_ON();  // 土壤湿度低于阈值，开启浇水
    }
}
```

## 📊 三种方案对比

| 特性 | 方案一（使用MH_RD） | 方案二（添加Soil） | 方案三（完整方案） |
|------|-------------------|-------------------|-------------------|
| **修改代码量** | 最少（1行） | 中等（修改结构体） | 最多（修改多处） |
| **可读性** | 一般 | 好 | 最好 |
| **扩展性** | 一般 | 好 | 最好 |
| **推荐度** | ⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐⭐⭐⭐⭐ |

## 🔍 为什么要使用全局数据结构？

### 1. **数据集中管理**
```c
// 不使用全局结构（分散）
float temp_value;
float humi_value;
float soil_value;
// 数据分散在各处，难以管理

// 使用全局结构（集中）
data.Variable.Temp
data.Variable.Humi
data.Variable.Soil
// 所有数据集中在一个结构体中
```

### 2. **便于模块间通信**
```c
// 显示模块
void Display(void) {
    OLED_ShowNum(0, 0, data.Variable.Temp, 2, OLED_6X8);
}

// 控制模块
void Control(void) {
    if(data.Variable.Temp > data.Threshold.Temp) {
        // 温度过高，执行降温
    }
}

// 上传模块
void Upload(void) {
    sprintf(buff, "{\"Temp\":%.1f}", data.Variable.Temp);
}

// 三个模块都访问同一个数据源，保证数据一致性
```

### 3. **支持数据持久化**
```c
// 可以将整个结构体保存到Flash
void Save_Data(void) {
    Flash_Write(&data, sizeof(dt));
}

// 可以从Flash恢复数据
void Load_Data(void) {
    Flash_Read(&data, sizeof(dt));
}
```

### 4. **便于调试**
```c
// 可以一次性查看所有数据
void Debug_Print(void) {
    Serial_Printf("Temp: %.1f\r\n", data.Variable.Temp);
    Serial_Printf("Humi: %.1f\r\n", data.Variable.Humi);
    Serial_Printf("Soil: %.1f\r\n", data.Variable.Soil);
    Serial_Printf("Mode: %d\r\n", data.flag.mode);
}
```

## 💡 实现原理

### 数据流向
```
传感器读取 → 局部变量 → 全局结构体 → 其他模块使用

DHT11_Read_Data(&temp, &humi)
        ↓
    temp, humi (局部变量)
        ↓
    data.Variable.Temp = temp
    data.Variable.Humi = humi
        ↓
    全局数据结构 (data)
        ↓
    ├─→ 显示模块读取
    ├─→ 控制模块读取
    ├─→ 上传模块读取
    └─→ 其他模块读取
```

### 内存布局
```c
// 全局数据结构在内存中的布局
dt data = {
    .Variable = {
        .Temp = 0.0,    // 偏移量: 0
        .Humi = 0.0,    // 偏移量: 4
        .MH_RD = 0.0    // 偏移量: 8
    },
    .Threshold = {
        .Temp = 0.0,    // 偏移量: 12
        .Humi = 0.0     // 偏移量: 16
    },
    .flag = {
        // ...
    }
};

// 访问时通过偏移量计算地址
data.Variable.Temp  → &data + 0
data.Variable.Humi  → &data + 4
data.Variable.MH_RD → &data + 8
```

## 🎯 推荐实现步骤

### 步骤1：使用现有字段（最简单）
```c
// 在Update_TempHuim_Display函数中添加一行
data.Variable.MH_RD = Humi_Soil;
```

### 步骤2：在其他地方使用
```c
// 在上传函数中
sprintf(buff, 
    "{\"Temp\":%.1f,\"Humi\":%.1f,\"Soil\":%.1f}",
    data.Variable.Temp,
    data.Variable.Humi,
    data.Variable.MH_RD
);

// 在控制函数中
if(data.Variable.MH_RD < 30.0) {
    relay_ON();
}
```

### 步骤3：（可选）重命名字段
```c
// 如果觉得MH_RD不够清晰，可以在main.h中重命名
typedef struct 
{
    float Temp;
    float Humi;
    float Soil;  // 改名为Soil，更清晰
} var;
```

## ✅ 总结

**推荐使用方案一**：
```c
data.Variable.MH_RD = Humi_Soil;
```

**原因**：
1. ✅ 不需要修改数据结构定义
2. ✅ 只需添加一行代码
3. ✅ 立即可用
4. ✅ 与温湿度存储方式一致
5. ✅ 便于其他模块访问

**核心原理**：
- 全局数据结构提供统一的数据访问接口
- 所有模块通过同一个结构体访问数据
- 保证数据一致性和可维护性